c1=46681133373252528334300906275176003837231476202396301214894813519313306619830568008346673028450784225333157108149939270719726994873922343199809839805627067397452334032990155531795059706828824561003783280737037455147402174559045616710478897135418675247261174167904626330233613425972851856745234145707815921208465158174774895774566540430986048122747503898066127674257296178379341236138433961267822178207293976201038143547411115509949687848299352886958141853514515474926035489604545469266689943365899902733164204596534983402246191798920742065480463037759109477305303068862798214798456072813361462762662215485193297579243342216061407388230092979686462587333622285610182403351667639656387839938212492478657824232241340940925340282559291441317133248381225136842848326839705175620593338165314539428757171071001775874357904793775268952927377958332750021713476710172077304837841681585909778588575337372811861711451120957604347105058188752480373960182839489202088407424436759422666799103202328347648586435459759
c2=35941559495157859807991973170918474587970999772595069495386457045163989501219524914057002963258088654463987743603581128124409769180550889921359647840399051000641517610657753633452675805194270559259984649285645933297881542918306693591576923031838555530160821458513568520019734127388594014478851482857158792919726722405368384256884088192094119046479785888098302871052649704423669579735651155234868529082558579492087149624200443277744123513229204943660915457600424414000353085963201121706897093398750579948764941605799074985417672673728643732117526938236206248732423801154761344485142825647946777993712272769219787695556091921219787958913829901387074435845052942244794302862227470872027713771834975484799514478425669187663792665047377709198806346915543851105904188533476310580052313636514731824243061308159869653087544123178980118997879197445569356210972660455366337530837547669233760778125


from Crypto.Util.number import *
from libnum import n2s
from gmpy import invert


def  getExponents():
    possible_primes = [i for i in range(1000) if isPrime(i)]
    d = {} #to store all possible values of e2+e2^2 
    maximum = possible_primes[-1]**2 + possible_primes[-1]
    for i in possible_primes:
        d[i**2+i] = i
    for prime in possible_primes:
        curr = 0
        degree = 1
        while curr < maximum:
            curr += prime**degree
            if(curr in d and d[curr] != prime): 
                print(f"e1: {prime}, e2:{d[curr]}, x: {degree}")
                break
            degree += 1

def getR():
    x = 4
    r = 2
    while True:
        r *= x
        if(len(r.bits())>1024 and is_prime(r-1)):
            r -= 1
            break
    print(f"r is: {r}")
n = 235626422771812360156301460295447678247114862792823628566671437703894399296212996731923428958102150152294907758424828860102461483828572891255093676540696786710267839605889455974419363045575602645171791648951388493464439708994524968391028252802572566954795914419664760006824825588990928628925492877730622870167153721864338793005353088277949434794462024901128437522649945723641781530023840490611226576438033827302501565951887229316697650932725988296785207565442038016115235460176936506183413326595860233335100664378153639027038968735828589990097743244890000920444486718518885602757491517234490819406143690500839275915809421961849367413145252610003403367181013242912429219810478522574333792716226821144287777560425025214219546414655133560523885953493320789393479997991406534263790044799843102071758842209350910446225586206327089680490537057793750176037177458729988252116259090895829404720204721160780682827181572448695150071004976309633211099140709035175473112081705220149430578342284800811754939409784539
r = 10407932194664399081925240327364085538615262247266704805319112350403608059673360298012239441732324184842421613954281007791383566248323464908139906605677320762924129509389220345773183349661583550472959420547689811211693677147548478866962501384438260291732348885311160828538416585028255604666224831890918801847068222203140521026698435488732958028878050869736186900714720710555703168729087
assert n% r == 0

pq = n//r
ip = 86382223550814732620321081543174019262935130492167868692680865114537692095248009201254486200461760640514113170697468280591204192906583625360853333849234262776655682242235720859708767595235967306758159403177915222505703845943538742431720864150507057971717337268539570132309534167135860132164163451364430193602
iq = 65505985829050621754273292397955022899240705954409722616198307560506717750666029524214826703576233205715903292992328465786288761844184213139984893110913912483672982242587597138037640594994056517725768559576577138653593514953590241822477884151163471025048189618233810197212845609387044697394133267018367571448
from sympy import Symbol,Eq,solve


def derivePQ(z):
    p=Symbol('p')
    q=Symbol('q')
    equation1 = Eq(ip*p+iq*q-z*pq-1,0)
    equation2 = Eq(p*q-pq,0)
    solution = solve((equation1,equation2),(p,q))

    p,q = None, None
    for poss_p,poss_q in solution:
        if(poss_p % 4 == 3 and poss_q % 4 == 3):
            p = poss_p
            q = poss_q
            break
    assert n % q == 0
    assert n % p == 0
    print("z:", z)
    print("p:", p )
    print("q:", q )

def bruteForceZ():
    for z in range(100,0,-1):
        try:
            derivePQ(z)
        except:
            pass

bruteForceZ()
e1 = 2
e2 = 5
p = 132969976560380364756405457236504324327642736218689166218498460053975353653484804005022170668231847712058238486344719676346161199732615918526950174313604550134411447730037222765818328560872413853515080681392621997800253274244426148033994548505665697302838975742484201316999756264355989960562135651279694943583
q = 170257379029480563912671070339436131511262890558847332579579298527920515294045121592089964317868076426677059991034463450266818161560795748978845443931267262696711874570485212890614474833477678985060451351460555647263055916552183493711091254353189998144013773455201368165765670059392871912023228035760652760059
r = 10407932194664399081925240327364085538615262247266704805319112350403608059673360298012239441732324184842421613954281007791383566248323464908139906605677320762924129509389220345773183349661583550472959420547689811211693677147548478866962501384438260291732348885311160828538416585028255604666224831890918801847068222203140521026698435488732958028878050869736186900714720710555703168729087
assert p * q * r == n



def getFirstHalf():
    mp = pow(c1, (p+1)//4, p)
    mq = pow(c1, (q+1)//4, q)
    mr = pow(c1, (r+1)//4, r)

    _mp = -mp % p
    _mq = -mq % q
    _mr = -mr % r

    b1 = pow((q*r ) % p,-1,p)*1
    b2 = pow((p*r ) % q,-1,q)*1
    b3 = pow((p*q ) % r,-1,r)*1

    x1 = (mp*b1*(q*r)+mq*b2*p*r +mr*b3*p*q)%(p*q*r)
    x2 = (_mp*b1*(q*r)+mq*b2*p*r +mr*b3*p*q)%(p*q*r)
    x3 = (mp*b1*(q*r)+_mq*b2*p*r +mr*b3*p*q)%(p*q*r)
    x4 = (mp*b1*(q*r)+mq*b2*p*r +_mr*b3*p*q)%(p*q*r)
    x5 = p*q*r-x1
    x6 = p*q*r-x2
    x7 = p*q*r-x3
    x8 = p*q*r-x4

    for pt in [x1,x2,x3,x4,x5,x6,x7,x8]:
        try:
            test = n2s(pt).decode('utf-8')
            print(test)
        except:
            pass

def getSecondHalf():
    phi = (p-1)* (q-1) * (r-1)
    d = int(invert(e2,phi))
    m = pow(c2, d, n)
    print(n2s(m))

# getFirstHalf()
# getSecondHalf()


