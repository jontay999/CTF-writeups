## Crypto Challenge: Wringing Rings

### Description/Source

```py
import sympy as sp
import random
import signal
from secret import FLAG

secret = random.SystemRandom().randint(1, 500_000)

_MAX = 10 ** (len(str(secret)) - 1)

# generating a polynomial
def _f(secret, minimum=3):
    coeffs = [secret] + [
        random.SystemRandom().randint(1, _MAX) for _ in range(minimum - 1)
    ]

    print("Secret Polynomial:")
    f_str = str(secret)
    for i, coeff in enumerate(coeffs[1:]):
        f_str += " + " + str(coeff) + "*x^" + str(i + 1)
    print(f_str)

    def f(x):
        res = 0
        for i, coeff in enumerate(coeffs):
            res += coeff * x ** (i)

        return res

    return f


def gen_shares(secret, minimum=3):
    f = _f(secret, minimum)
    shares = [(i + 1, f(i + 1)) for i in range(minimum)]
    return shares


def challenge(secret, minimum=3):
    shares = gen_shares(secret, minimum)
    points = random.sample(shares, minimum - 1)
    points.sort()
    return points


def main():
    minimum = 10
    points = challenge(secret, minimum)

    print("[SSSS] Known shares of the secret polynomial: ")
    for point in points:
        print(f"       {point}")
    print()

    signal.alarm(60)
    guess = int(input("[SSSS] Enter my secret: "))
    if guess == secret:
        print(f"[SSSS] Correct! {FLAG}")
    else:
        print("[SSSS] Incorrect...")

if __name__ == "__main__":
    main()

```

A kinda similar challenge to this year's Securinet's Final 2022 challenge yor_forger, so the main explanation can be checked out from my writeup for that.

We are given 9 out of 10 shares in Shamir's Secret Sharing Scheme and tasked to find the `secret` which is essentially the first coefficient. Since the secret is quite small, we can use LLL to retrieve it. We build the matrix and use scale factors based on the maximum value, and get the secret

```py
xs = [s[0] for s in shares]
ys = [s[1] for s in shares]

total_vars = 10
mm = [
    [x^i for x in xs] + [1 if j == i else 0 for j in range(total_vars)] for i in range(total_vars)
]
B = matrix(ZZ, mm)

scale = 19 # 500k ~= 2^19
scale_factors = [2^scale for _ in range(9)] + [2^(-scale) for _ in range(10)]

t = vector(ZZ, ys + [2^scale for _  in range(10)])

closest_vector = solve_cvp2(B, t, scale_factors, verbose=True)

secret = closest_vector[9] #484244
```

There is a far simpler solution based on the fact that it is not working within a ring, so only positive integers are considered so z3 or sympy can solve it quite quickly but this solves a harder variant.

### Solver

```python
from pwn import *
from libnum import *

# nc ring.chal.uiuc.tf 1337
def solve_cvp(B, t, verbose=False):
    """
    Approximately and efficiently solves the closest vector problem.

    Arguments:
        B: a matrix whose rows are the basis vectors.
        t: the target vector.
        verbose: if True, print out useful information while solving.

    Return:
        A vector in the lattice generated by `B` (approximately) closest to `t`.

    """
    #  perform vector projecting using the Gram-Schmidt process
    t_ = t - B.stack(t).gram_schmidt()[0].row(-1)
    if verbose:
        print( "Target vector projection:")
        print( numerical_approx(t_, digits=4))

    # apply the LLL algorithm
    B_ = B.LLL()
    if verbose:
        print( "\nLLL-reduced basis:")
        print( numerical_approx(B_, digits=4))

    # find the exact linear combination of vectors in `B_` that produces `t_`
    c = B_.solve_left(t_)

    # round each coefficient to its nearest integer
    c_ = vector(map(round, c))
    if verbose:
        print( "\nRound-off errors:")
        print( numerical_approx(vector(map(abs, c - c_)), digits=4))

    # output the result
    return c_ * B_


def solve_cvp2(B, t, scale_factors=None, verbose=False):
    """
    A wrapper of `solve_cvp` to perform coordinate scaling.

    Arguments:
        scale_factors: a list of scale factors. The 1st, 2nd, 3rd, ... factor
            will be used for the 1st, 2nd, 3rd, ... coordinate.

    """
    if not scale_factors:
        scale_factors = [1] * B.ncols()

    if verbose:
        print( "Scale factors:")
        print( numerical_approx(vector(scale_factors), digits=4), '\n')

    scale_matrix = diagonal_matrix(scale_factors)
    return solve_cvp(B*scale_matrix, t*scale_matrix, verbose) * scale_matrix^-1


host, port = "ring.chal.uiuc.tf", 1337

p = remote(host, port)
p.recvlines(2)
shares = []
for _ in range(9):
    share = eval(p.recvline().strip().decode('utf-8'))
    shares.append(share)
print(shares)
p.interactive()
shares = [
    (1, 985484),
    (2, 55969040),
    (4, 15057563108),
    (5, 98465179304),
    (6, 464720920544),
    (7, 1743680487050),
    (8, 5518708462676),
    (9, 15317914758308),
    (10, 38303904206864),
]


xs = [s[0] for s in shares]
ys = [s[1] for s in shares]

total_vars = 10
mm = [
    [x^i for x in xs] + [1 if j == i else 0 for j in range(total_vars)] for i in range(total_vars)
]
B = matrix(ZZ, mm)


# x0,x1,x2,x3,x4,x5,x6,x7,x8 = xs
# y0,y1,y2,y3,y4,y5,y6,y7,y8 = ys
# B = matrix(ZZ, [
#     [1   , 1   , 1   ,    1,    1,   1,     1,    1,    1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
#     [x0  , x1  , x2  ,   x3,   x4,   x5,   x6,   x7,   x8, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0],
#     [x0^2, x1^2, x2^2, x3^2, x4^2, x5^2, x6^2, x7^2, x8^2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0],
#     [x0^3, x1^3, x2^3, x3^3, x4^3, x5^3, x6^3, x7^3, x8^3, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0],
#     [x0^4, x1^4, x2^4, x3^4, x4^4, x5^4, x6^4, x7^4, x8^4, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
#     [x0^5, x1^5, x2^5, x3^5, x4^5, x5^5, x6^5, x7^5, x8^5, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
#     [x0^6, x1^6, x2^6, x3^6, x4^6, x5^6, x6^6, x7^6, x8^6, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
#     [x0^7, x1^7, x2^7, x3^7, x4^7, x5^7, x6^7, x7^7, x8^7, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0],
#     [x0^8, x1^8, x2^8, x3^8, x4^8, x5^8, x6^8, x7^8, x8^8, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0],
#     [x0^9, x1^9, x2^9, x3^9, x4^9, x5^9, x6^9, x7^9, x8^9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
# ])

scale = 19 # 500k ~= 2^19
scale_factors = [2^scale for _ in range(9)] + [2^(-scale) for _ in range(10)]

t = vector(ZZ, ys + [2^scale for _  in range(10)])

closest_vector = solve_cvp2(B, t, scale_factors, verbose=True)

secret = closest_vector[9] #484244


```

### Flag

```
uiuctf{turn5_0ut_th4t_th3_1nt3g3r5_4l50_5uck}
```

### Notes

- https://colab.research.google.com/github/nguyenduyhieukma/CTF-Writeups/blob/master/Google%20CTF%20Quals/2019/reality/reality-solution.ipynb
- [Similar Challenge from Securinets Final](../Securinets%202022/Crypto.md)
- https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing#Problem
